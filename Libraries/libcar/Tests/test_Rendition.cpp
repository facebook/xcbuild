/**
 Copyright (c) 2015-present, Facebook, Inc.
 All rights reserved.

 This source code is licensed under the BSD-style license found in the
 LICENSE file in the root directory of this source tree. An additional grant
 of patent rights can be found in the PATENTS file in the same directory.
 */

#include <gtest/gtest.h>
#include <car/Rendition.h>
#include <car/car_format.h>

using car::Rendition;

struct test_car_key_format {
    struct car_key_format keyfmt;
    uint32_t identifier_list[13];
} __attribute__((packed));

static struct test_car_key_format keyfmt_s = {
    {
        { 'k', 'f', 'm', 't' }, 0, 13,
    },
    {
        car_attribute_identifier_scale,
        car_attribute_identifier_idiom,
        car_attribute_identifier_subtype,
        car_attribute_identifier_graphics_class,
        car_attribute_identifier_memory_class,
        car_attribute_identifier_size_class_horizontal,
        car_attribute_identifier_size_class_vertical,
        car_attribute_identifier_identifier,
        car_attribute_identifier_element,
        car_attribute_identifier_part,
        car_attribute_identifier_state,
        car_attribute_identifier_value,
        car_attribute_identifier_dimension1,
    }
};

static struct car_key_format *keyfmt = &keyfmt_s.keyfmt;

TEST(Rendition, TestRenditionDeSerializeSerialize)
{
    uint16_t rendition_key[13] = {
        1,                                        // scale
        car_attribute_identifier_idiom_value_pad, // idiom
        3,                                        // subtype
        4,                                        // graphics_class
        5,                                        // memory_class
        car_attribute_identifier_size_class_value_compact, // size_class_horizontal
        car_attribute_identifier_size_class_value_regular, // size_class_vertical
        8,                                        // identifier
        9,                                        // element
        10,                                       // part
        11,                                       // state
        12,                                       // value
        13,                                       // dimension1
    };

    size_t rendition_len = 598;
    const unsigned char rendition_value[598] = {
        0x49, 0x53, 0x54, 0x43, 0x01, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
        0x10, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 0x42, 0x47, 0x52, 0x41, 0x01, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x64, 0x6f, 0x74, 0x2e, 0x70, 0x6e, 0x67, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x68, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x36, 0x01, 0x00, 0x00, 0xe9, 0x03, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
        0x10, 0x00, 0x00, 0x00, 0xeb, 0x03, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x10, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0xec, 0x03, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0xee, 0x03, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x00, 0x00, 0xef, 0x03, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
        0x4d, 0x4c, 0x45, 0x43, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x26, 0x01, 0x00, 0x00,
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xa5, 0x93, 0x4f, 0x8e, 0x01, 0x41,
        0x14, 0xc6, 0x7f, 0x1d, 0xd3, 0xdd, 0x24, 0xc2, 0x0e, 0x67, 0xf0, 0xf7, 0x08, 0x93, 0xd9, 0x9a,
        0xc8, 0xac, 0xd9, 0x99, 0x03, 0x60, 0xa9, 0x37, 0x9d, 0x71, 0x01, 0x2c, 0x48, 0x1c, 0x02, 0x17,
        0x10, 0xb7, 0x10, 0xdc, 0x00, 0x6b, 0x16, 0x58, 0x4d, 0xbe, 0x45, 0x25, 0x48, 0x7a, 0x46, 0xb7,
        0x2f, 0xa9, 0xa4, 0xea, 0xbd, 0xfa, 0x55, 0xbd, 0x7c, 0xf5, 0x0a, 0xee, 0x95, 0xcf, 0x90, 0xef,
        0x57, 0xe9, 0x6f, 0xda, 0x6c, 0xce, 0x3f, 0x9c, 0x35, 0xd6, 0x6d, 0xd6, 0x8a, 0x29, 0x47, 0x80,
        0x9c, 0x18, 0xce, 0xa8, 0xc6, 0xe8, 0xe0, 0x71, 0xf0, 0xde, 0xf1, 0x4a, 0x59, 0x4a, 0xee, 0x1b,
        0xae, 0x86, 0xe6, 0x8a, 0x29, 0x37, 0xf9, 0x62, 0x92, 0xb0, 0x49, 0x3c, 0xb2, 0x8b, 0x26, 0x8b,
        0x59, 0x83, 0x59, 0x3a, 0x4e, 0x3a, 0xe8, 0x0e, 0xe5, 0xa6, 0x75, 0xa6, 0xcb, 0x6f, 0x96, 0x62,
        0x4c, 0x7c, 0x5c, 0x63, 0x3c, 0x6f, 0x30, 0xb7, 0x2c, 0xac, 0x20, 0xd6, 0x48, 0x7b, 0x74, 0x8f,
        0x6a, 0xd5, 0xba, 0x90, 0xa1, 0xb0, 0xef, 0xb2, 0x4f, 0xb9, 0xa4, 0xfe, 0x63, 0x8d, 0xb4, 0x77,
        0xd7, 0x65, 0x27, 0x76, 0x50, 0x65, 0xe0, 0x7f, 0xe0, 0x3f, 0xcb, 0x1a, 0xc9, 0x0f, 0xb1, 0xf2,
        0xb9, 0x92, 0xa3, 0x12, 0x96, 0x97, 0xa7, 0x62, 0x2f, 0x3d, 0x2e, 0xf2, 0x38, 0x2c, 0x2f, 0xff,
        0xc4, 0x46, 0xe5, 0x93, 0x0e, 0xc9, 0xa3, 0xcf, 0x31, 0x6a, 0xfd, 0xe5, 0x1c, 0xe5, 0x55, 0x8b,
        0xd5, 0x2b, 0xfe, 0x0d, 0x3f, 0x19, 0x16, 0xb3, 0x14, 0xf5, 0x16, 0x51, 0xde, 0x4f, 0xac, 0xd6,
        0xea, 0x1f, 0xf5, 0x44, 0x98, 0xfe, 0x11, 0x63, 0x62, 0xaf, 0xf6, 0xaf, 0x39, 0xe3, 0xf6, 0xff,
        0xa8, 0x36, 0x3b, 0x86, 0xad, 0xb8, 0xe6, 0x7f, 0xfd, 0x9f, 0x5b, 0xa9, 0x27, 0xe5, 0xcb, 0xb6,
        0xc3, 0xf6, 0xda, 0xe3, 0x7a, 0xf2, 0x39, 0xc9, 0x67, 0xe3, 0xd5, 0xe3, 0xfe, 0x5f, 0x50, 0x6c,
        0x83, 0xa9, 0x00, 0x04, 0x00, 0x00,
    };

    car::AttributeList attributes = car::AttributeList::Load(keyfmt->num_identifiers, keyfmt->identifier_list, rendition_key);

    ext::optional<uint16_t> scale = attributes.get(car_attribute_identifier_scale);
    EXPECT_TRUE(scale);
    EXPECT_TRUE(*scale == 1);

    ext::optional<uint16_t> idiom = attributes.get(car_attribute_identifier_idiom);
    EXPECT_TRUE(idiom);
    EXPECT_TRUE(*idiom == car_attribute_identifier_idiom_value_pad);

    ext::optional<uint16_t> facet_identifier = attributes.get(car_attribute_identifier_identifier);
    EXPECT_TRUE(facet_identifier);
    EXPECT_TRUE(*facet_identifier == 8);

    ext::optional<uint16_t> size_class_horizontal = attributes.get(car_attribute_identifier_size_class_horizontal);
    EXPECT_TRUE(size_class_horizontal);
    EXPECT_TRUE(*size_class_horizontal == car_attribute_identifier_size_class_value_compact);

    ext::optional<uint16_t> size_class_vertical = attributes.get(car_attribute_identifier_size_class_vertical);
    EXPECT_TRUE(size_class_vertical);
    EXPECT_TRUE(*size_class_vertical == car_attribute_identifier_size_class_value_regular);

    auto attributes_out = attributes.write(keyfmt->num_identifiers, keyfmt->identifier_list);
    EXPECT_TRUE(0 == memcmp(rendition_key, (uint16_t *)&attributes_out[0], sizeof(uint16_t) * keyfmt->num_identifiers));

    car::Rendition rendition = car::Rendition::Load(attributes, (struct car_rendition_value *)rendition_value);

    car::Rendition::Data::Format format = car::Rendition::Data::Format::PremultipliedBGRA8;
    std::vector<uint8_t> test_bitmap_bytes = {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x2a, 0x16, 0x00, 0x2a, 0x8e, 0x4a, 0x00, 0x8e, 0xd7, 0x6f, 0x00, 0xd7, 0xf8, 0x80, 0x00, 0xf8,
        0xf8, 0x80, 0x00, 0xf8, 0xd6, 0x6f, 0x00, 0xd6, 0x8e, 0x4a, 0x00, 0x8e, 0x2a, 0x16, 0x00, 0x2a,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x03, 0x00, 0x06, 0x94, 0x4d, 0x00, 0x94,
        0xe9, 0x79, 0x00, 0xe9, 0x79, 0x3f, 0x00, 0x79, 0x2d, 0x17, 0x00, 0x2d, 0x07, 0x04, 0x00, 0x07,
        0x07, 0x04, 0x00, 0x07, 0x2d, 0x17, 0x00, 0x2d, 0x79, 0x3f, 0x00, 0x79, 0xe9, 0x79, 0x00, 0xe9,
        0x98, 0x4f, 0x00, 0x98, 0x09, 0x05, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x06, 0x03, 0x00, 0x06, 0xbb, 0x61, 0x00, 0xbb, 0xad, 0x5a, 0x00, 0xad,
        0x0f, 0x08, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x08, 0x00, 0x0f,
        0xac, 0x59, 0x00, 0xac, 0xbd, 0x62, 0x00, 0xbd, 0x06, 0x03, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x95, 0x4d, 0x00, 0x95, 0xae, 0x5a, 0x00, 0xae, 0x01, 0x01, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x01, 0x01, 0x00, 0x01, 0xad, 0x5a, 0x00, 0xad, 0x94, 0x4d, 0x00, 0x94, 0x00, 0x00, 0x00, 0x00,
        0x2b, 0x16, 0x00, 0x2b, 0xe8, 0x78, 0x00, 0xe8, 0x0e, 0x07, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x0e, 0x07, 0x00, 0x0e, 0xe7, 0x78, 0x00, 0xe7, 0x2b, 0x16, 0x00, 0x2b,
        0x8f, 0x4a, 0x00, 0x8f, 0x7e, 0x41, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x79, 0x3f, 0x00, 0x79, 0x8f, 0x4a, 0x00, 0x8f,
        0xd7, 0x6f, 0x00, 0xd7, 0x2f, 0x18, 0x00, 0x2f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2d, 0x17, 0x00, 0x2d, 0xd7, 0x6f, 0x00, 0xd7,
        0xf9, 0x81, 0x00, 0xf9, 0x07, 0x04, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x03, 0x00, 0x06, 0xf9, 0x81, 0x00, 0xf9,
        0xf9, 0x81, 0x00, 0xf9, 0x07, 0x04, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x06, 0x00, 0x0c, 0xf3, 0x7e, 0x00, 0xf3,
        0xd7, 0x6f, 0x00, 0xd7, 0x2f, 0x18, 0x00, 0x2f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2e, 0x18, 0x00, 0x2e, 0xd4, 0x6e, 0x00, 0xd4,
        0x8f, 0x4a, 0x00, 0x8f, 0x7e, 0x41, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x79, 0x3f, 0x00, 0x79, 0x90, 0x4b, 0x00, 0x90,
        0x2c, 0x17, 0x00, 0x2c, 0xe7, 0x78, 0x00, 0xe7, 0x0e, 0x07, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x0e, 0x07, 0x00, 0x0e, 0xe7, 0x78, 0x00, 0xe7, 0x2c, 0x17, 0x00, 0x2c,
        0x00, 0x00, 0x00, 0x00, 0x95, 0x4d, 0x00, 0x95, 0xad, 0x5a, 0x00, 0xad, 0x01, 0x01, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x01, 0x01, 0x00, 0x01, 0xad, 0x5a, 0x00, 0xad, 0x95, 0x4d, 0x00, 0x95, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x06, 0x03, 0x00, 0x06, 0xbb, 0x61, 0x00, 0xbb, 0xad, 0x5a, 0x00, 0xad,
        0x0f, 0x08, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x08, 0x00, 0x0f,
        0xac, 0x59, 0x00, 0xac, 0xbd, 0x62, 0x00, 0xbd, 0x06, 0x03, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x03, 0x00, 0x06, 0x94, 0x4d, 0x00, 0x94,
        0xe9, 0x79, 0x00, 0xe9, 0x79, 0x3f, 0x00, 0x79, 0x2c, 0x17, 0x00, 0x2c, 0x05, 0x03, 0x00, 0x05,
        0x06, 0x03, 0x00, 0x06, 0x2c, 0x17, 0x00, 0x2c, 0x79, 0x3f, 0x00, 0x79, 0xe9, 0x79, 0x00, 0xe9,
        0x98, 0x4f, 0x00, 0x98, 0x09, 0x05, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x2b, 0x16, 0x00, 0x2b, 0x90, 0x4b, 0x00, 0x90, 0xd8, 0x70, 0x00, 0xd8, 0xfa, 0x81, 0x00, 0xfa,
        0xf4, 0x7e, 0x00, 0xf4, 0xd4, 0x6e, 0x00, 0xd4, 0x90, 0x4b, 0x00, 0x90, 0x2c, 0x17, 0x00, 0x2c,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    };

    // Check the data decoded from rendition_value, and check that it matches test_bitmap_bytes
    auto decodeData = rendition.data();
    auto decodeDataVector = decodeData->data();
    EXPECT_TRUE(decodeDataVector.size() == test_bitmap_bytes.size());
    for (int i = 0; i < test_bitmap_bytes.size(); i++) {
        EXPECT_TRUE(decodeDataVector[i] == test_bitmap_bytes[i]);
    }

    // Construct an identical Rendition instance using test_bitmap_bytes
    auto new_rendition_data = ext::optional<car::Rendition::Data>(car::Rendition::Data(test_bitmap_bytes, format));
    car::Rendition new_rendition = car::Rendition::Create(attributes, new_rendition_data);
    new_rendition.width() = 16;
    new_rendition.height() = 16;
    new_rendition.scale() = 1.0;
    new_rendition.fileName() = std::string("dot.png");
    new_rendition.layout() = car_rendition_value_layout_one_part_scale;

    EXPECT_TRUE(rendition.width() == new_rendition.width());
    EXPECT_TRUE(rendition.height() == new_rendition.height());
    EXPECT_TRUE(rendition.scale() == new_rendition.scale());
    EXPECT_TRUE(0 == strcmp(rendition.fileName().c_str(), new_rendition.fileName().c_str()));
    EXPECT_TRUE(rendition.layout() == new_rendition.layout());

    // Check that serialized attributes match the rendition_key
    auto new_rendition_key = new_rendition.attributes().write(keyfmt->num_identifiers, keyfmt->identifier_list);
    EXPECT_TRUE(0 == memcmp(&new_rendition_key[0], rendition_key, sizeof(uint16_t) * keyfmt->num_identifiers));

    // Serialise new_rendition.
    auto new_rendition_value = new_rendition.write();

    // Check that rendition_value matches the serialized rendition created using test_bitmap_bytes.
    EXPECT_TRUE(0 == memcmp(rendition_value, &new_rendition_value[0], rendition_len));

    // Decode the serialized copy of new_rendition.
    car::Rendition new_rendition_check = car::Rendition::Load(attributes,
        reinterpret_cast<struct car_rendition_value *>(new_rendition_value.data()));
    auto check_data = new_rendition_check.data();

    // Check that the encoded and decoded data is the same length
    EXPECT_TRUE(check_data->data().size() == test_bitmap_bytes.size());

    // Check that the encoded and decoded test_bitmap_bytes is the same as the original
    auto v = check_data->data();
    EXPECT_TRUE(v == test_bitmap_bytes);
}

TEST(Rendition, TestRenditionJPEG)
{
    uint16_t rendition_key[13] = {
        1,                                        // scale
        car_attribute_identifier_idiom_value_pad, // idiom
        3,                                        // subtype
        4,                                        // graphics_class
        5,                                        // memory_class
        car_attribute_identifier_size_class_value_compact, // size_class_horizontal
        car_attribute_identifier_size_class_value_regular, // size_class_vertical
        8,                                        // identifier
        9,                                        // element
        10,                                       // part
        11,                                       // state
        12,                                       // value
        13,                                       // dimension1
    };
    car::AttributeList attributes = car::AttributeList::Load(keyfmt->num_identifiers, keyfmt->identifier_list, rendition_key);

    car::Rendition::Data::Format test_data_format = car::Rendition::Data::Format::JPEG;
    size_t test_data_size = 10000;
    std::vector<uint8_t> test_data(test_data_size);
    for (unsigned int i = 0; i < test_data_size; i++) {
        test_data[i] = i & 0xFF;
    }

    // Construct a Rendition using a test pattern, since JPEG is stored as raw data
    auto data = ext::optional<car::Rendition::Data>(car::Rendition::Data(test_data, test_data_format));
    car::Rendition rendition = car::Rendition::Create(attributes, data);
    rendition.width() = 100;
    rendition.height() = 100;
    rendition.scale() = 1.0;
    rendition.fileName() = std::string("test.png");
    rendition.layout() = car_rendition_value_layout_one_part_scale;

    // Serialise rendition.
    std::vector<uint8_t> rendition_value = rendition.write();
   
    // deserialize and compare
    car::Rendition deserialized_rendition = car::Rendition::Load(attributes, reinterpret_cast<struct car_rendition_value *>(rendition_value.data()));

    auto deserialized_data = deserialized_rendition.data();
    auto deserialized_bytes = deserialized_data->data();

    EXPECT_TRUE(deserialized_data->format() == test_data_format);
    EXPECT_TRUE(deserialized_bytes == test_data);
}

TEST(Rendition, TestRenditionSlices)
{
    uint16_t rendition_key[13] = {
        1,                                        // scale
        car_attribute_identifier_idiom_value_pad, // idiom
        3,                                        // subtype
        4,                                        // graphics_class
        5,                                        // memory_class
        car_attribute_identifier_size_class_value_compact, // size_class_horizontal
        car_attribute_identifier_size_class_value_regular, // size_class_vertical
        8,                                        // identifier
        9,                                        // element
        10,                                       // part
        11,                                       // state
        12,                                       // value
        13,                                       // dimension1
    };
    car::AttributeList attributes = car::AttributeList::Load(keyfmt->num_identifiers, keyfmt->identifier_list, rendition_key);

    size_t width = 100;
    size_t height = 100;

    car::Rendition::Data::Format format = car::Rendition::Data::Format::PremultipliedBGRA8;
    std::vector<uint8_t> test_bitmap_bytes(width*height*4);

    // Construct a Rendition using test_bitmap_bytes and slices
    auto data = ext::optional<car::Rendition::Data>(car::Rendition::Data(test_bitmap_bytes, format));
    car::Rendition rendition = car::Rendition::Create(attributes, data);
    rendition.width() = width;
    rendition.height() = height;
    rendition.scale() = 1.0;
    rendition.fileName() = std::string("test.png");
    rendition.layout() = car_rendition_value_layout_nine_part_tile;

    // Add slices
    for (uint32_t i = 0, j = 0; i < 9; i++) {
        rendition.slices().push_back({++j,++j,++j,++j});
    }

    // Serialise rendition.
    std::vector<uint8_t> rendition_value = rendition.write();
   
    // deserialize and compare
    car::Rendition deserialized_rendition = car::Rendition::Load(attributes, reinterpret_cast<struct car_rendition_value *>(rendition_value.data()));

    EXPECT_TRUE(deserialized_rendition.slices().size() == rendition.slices().size());

    for (int i = 0; i < rendition.slices().size(); i++) {
        EXPECT_TRUE(deserialized_rendition.slices()[i].x == rendition.slices()[i].x);
        EXPECT_TRUE(deserialized_rendition.slices()[i].y == rendition.slices()[i].y);
        EXPECT_TRUE(deserialized_rendition.slices()[i].width == rendition.slices()[i].width);
        EXPECT_TRUE(deserialized_rendition.slices()[i].height == rendition.slices()[i].height);
    }
}

